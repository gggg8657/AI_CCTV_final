━━━━━━━━━━━━━━━━━━━━
AUTOMATED GIT & LINEAR WORKFLOW RULES
━━━━━━━━━━━━━━━━━━━━

모든 작업 전후로 자동으로 Git 상태를 체크하고, 형상관리를 수행하며, Linear 이슈를 업데이트합니다.

━━━━━━━━━━━━━━━━━━━━
WORKFLOW CHECKPOINTS (MANDATORY)
━━━━━━━━━━━━━━━━━━━━

[작업 시작 전]
1. Git 상태 확인:
   - `git status` 실행
   - 현재 브랜치 확인
   - 커밋되지 않은 변경사항 확인
   - 필요시 stash 또는 커밋

2. Linear 이슈 확인:
   - 작업할 이슈 확인
   - 이슈 상태를 "In Progress"로 업데이트
   - 시작 시간 기록

[작업 중]
- 파일 수정 시 실시간으로 변경사항 추적
- 의미있는 단위마다 커밋 고려

[작업 완료 후]
1. Git 형상관리:
   - `git status`로 변경사항 확인
   - `git diff`로 변경 내용 점검
   - 의미있는 단위로 `git add`
   - 적절한 커밋 메시지로 `git commit` (형식: `<type>: <description> [#ISSUE_KEY]`)
   - 커밋 내용 재확인: `git log -1 -p`

2. Linear 업데이트:
   - 작업 완료 시: 이슈 상태를 "Done"으로 업데이트
   - 부분 완료 시: 진행 상황 코멘트 추가
   - 다음 단계가 있으면 명시

━━━━━━━━━━━━━━━━━━━━
COMMIT RULES
━━━━━━━━━━━━━━━━━━━━

커밋 전 필수 체크리스트:
1. ✅ `git status` - 변경사항 확인
2. ✅ `git diff` - 변경 내용 점검
3. ✅ 커밋 메시지에 Linear 이슈 키 포함
4. ✅ 커밋 후 `git log -1`로 확인

커밋 메시지 형식:
```
<type>: <short description> [#ISSUE_KEY]

- 변경 내용 상세 설명
- 관련 파일 목록 (필요시)
```

━━━━━━━━━━━━━━━━━━━━
LINEAR UPDATE RULES
━━━━━━━━━━━━━━━━━━━━

작업 시작 시:
- 상태: "In Progress"
- 코멘트: "작업 시작 - [작업 내용 요약]"

작업 완료 시:
- 상태: "Done" (완전히 완료된 경우)
- 코멘트: "완료 - [완료된 내용] + [커밋 해시]"

부분 완료 시:
- 상태: "In Progress" 유지
- 코멘트: "진행 중 - [완료된 부분] / [남은 작업]"

━━━━━━━━━━━━━━━━━━━━
AUTOMATION TRIGGERS
━━━━━━━━━━━━━━━━━━━━

다음 상황에서 자동으로 체크포인트 실행:
1. 파일 수정/생성/삭제 후
2. 사용자가 "작업 완료" 또는 "커밋" 요청 시
3. Linear 이슈와 연관된 작업 완료 시
4. 브랜치 전환 전
5. 작업 세션 종료 전

━━━━━━━━━━━━━━━━━━━━
EXCEPTIONS
━━━━━━━━━━━━━━━━━━━━

다음 경우는 자동 커밋하지 않음:
- 임시 파일이나 테스트 파일
- 사용자가 명시적으로 "커밋하지 마" 요청 시
- 작업이 아직 완료되지 않은 경우 (Draft 상태)

━━━━━━━━━━━━━━━━━━━━
PERPLEXITY MCP RULES
━━━━━━━━━━━━━━━━━━━━

Perplexity MCP를 사용할 때:
1. **요청 쿼리 표시**: Perplexity에 보낸 검색 쿼리를 채팅창에 표시
2. **응답 원본 표시**: Perplexity 검색 결과는 요약하지 말고 **원본 응답 전체를 그대로 대화창에 표시**해야 함
3. **원문 보존**: 사용자가 검색 결과를 직접 확인할 수 있도록 원문을 보존
4. **별도 분석 제공**: 검색 결과를 기반으로 한 분석이나 요약은 별도로 제공하되, 원본 결과는 반드시 포함

표시 형식:
```
[Perplexity Search Query]
<검색 쿼리>

[Perplexity Search Results]
<원본 응답 전체>
- 결과 1: [제목] [URL] [전체 내용]
- 결과 2: [제목] [URL] [전체 내용]
...

[Analysis]
<필요시 추가 분석>
```

예시:
- ❌ 잘못된 방식: "Perplexity 검색 결과를 확인했습니다. 버전은 v0.2.6입니다."
- ✅ 올바른 방식:
  ```
  [Perplexity Search Query]
  Vision-Agents Security Camera Example event system architecture
  
  [Perplexity Search Results]
  결과 1: Chapter 13: Pattern 5: Vision-Based Agents
  URL: https://...
  [전체 내용 원문]
  
  [Analysis]
  검색 결과를 분석한 결과...
  ```

━━━━━━━━━━━━━━━━━━━━
CONDA + CODEX CLI + PERPLEXITY MCP RULES
━━━━━━━━━━━━━━━━━━━━

Always respond in Korean

## 0) Purpose
- Repo별 Conda 환경이 다른 상황에서도, 실행/재현/검증이 가능한 개발/연구 워크플로우를 강제한다.
- 코딩 작업은 Codex CLI를 "초안 생성기"로 사용하고, 본 에이전트(Cursor)는 최종 품질과 재현성(테스트/스모크)을 보장한다.
- 조사/팩트체크/최신 확인은 Perplexity MCP를 사용하며, 출처 기반으로만 결론을 내린다.
- 모든 답변은 실행 가능한 다음 액션(I propose...)를 포함한다.

---

## 1) Repo별 Conda Environment 규약 (강제)
### 1.1 Single Source of Truth(SSOT)
각 레포는 다음 중 최소 1개를 반드시 갖는다. 우선순위는 아래와 같다:
1) `environment.yml` (권장, 재현성 최우선)
2) `ENVIRONMENT.md` (설명/실행/검증 커맨드 문서)
3) (선택) `requirements.txt`/`pyproject.toml`/`conda-lock.yml` 등 보조

### 1.2 ENVIRONMENT.md 최소 템플릿(레포 루트)
`ENVIRONMENT.md`가 없다면, 코드 작업 전에 이를 먼저 추가하도록 제안한다.

- ENV_NAME: <conda env name>
- PYTHON: <version>
- CUDA: <version or "cpu">
- CREATE:
  - `conda env create -f environment.yml` (권장)
  - or `conda create -n <ENV_NAME> python=<ver>`
- ACTIVATE:
  - `conda activate <ENV_NAME>`
- VERIFY (최소 2개):
  - `python -V`
  - `python -c "import torch; print(torch.__version__, torch.cuda.is_available())"` (torch 사용 시)
- RUN (대표 1~3개):
  - 예) `python train.py ...`
  - 예) `python demo.py ...`
- TEST/SMOKE (최소 1개):
  - 예) `pytest -q`
  - 예) `python -m compileall .`
- NOTES:
  - GPU/드라이버/특이 사항, 데이터 경로, 권한 이슈

### 1.3 작업 시작 Preflight(필수)
개발/실험/디버깅에 착수하기 전에, 아래 체크를 항상 수행한다:
- [ ] 레포 루트 기준 작업인지 확인(경로 명시)
- [ ] Conda env 활성화 명시: `conda activate <ENV_NAME>`
- [ ] VERIFY 커맨드 최소 2개 확보 및 실행 가능 상태 확인
- [ ] 재현 커맨드(에러 재현/실험 실행) 최소 1개 확보
- [ ] 변경 후 검증 커맨드(TEST/SMOKE) 최소 1개 확보

Preflight 정보가 없으면:
- 에이전트는 먼저 필요한 정보를 "확보하는 액션"을 제안하고, 무리한 추측으로 진행하지 않는다.

### 1.4 Env 매핑(개인 워크스페이스 권장 규약)
(권장) 상위 디렉토리에 `REPO_ENVS.md`를 유지한다.
- repo_path → env_name → python/cuda → run/test → notes

에이전트는 레포가 바뀌면 항상 env 매핑을 확인/갱신하도록 제안한다.

---

## 2) Codex CLI 협업 규약 (코딩/개발 작업)
### 2.1 Codex는 "패치 생성기", Cursor는 "검수자"
- Codex의 출력은 기본적으로 unified diff(패치) 형태를 요구한다.
- Cursor는 패치를 적용하기 전후로 재현/검증 커맨드를 제시하고, 리스크를 평가한다.

### 2.2 Codex 입력 프롬프트 표준(구조화 강제)
Codex 호출 시 항상 아래 섹션을 포함한다:

- [GOAL] 정확히 무엇을 바꾸는가
- [CONSTRAINTS]
  - "Output must be unified diff"
  - "Do not change unrelated files"
  - "Include commands: reproduce + verify"
  - "Respect Conda env: <ENV_NAME>, Python: <ver>"
- [CONTEXT]
  - repo 구조, 관련 파일 경로, 사용 라이브러리/버전
- [INPUTS]
  - 에러 로그/현재 코드/재현 방법
- [OUTPUTS]
  - patch/diff
  - run commands
  - tests/smoke commands
- [VALIDATION]
  - 최소 재현 1개, 검증 1개

### 2.3 Codex 호출 템플릿(예시)
```bash
export PROMPT=$(cat <<'EOF'
[GOAL]
...

[CONSTRAINTS]
- Output must be unified diff.
- Provide reproduce + verify commands.
- Conda env: <ENV_NAME>, Python: <ver>
- Do not modify unrelated files.

[CONTEXT]
...

[INPUTS]
...

[OUTPUTS]
- Unified diff patch
- Commands to reproduce + verify

[VALIDATION]
- Reproduce:
- Verify:
EOF
)

codex <<'EOF'
$PROMPT
EOF
```

### 2.4 Codex 응답 표시 규칙 (필수)
Codex CLI를 사용할 때는 다음 규칙을 반드시 준수한다:

1. **요청 프롬프트 표시**: Cursor가 Codex에 보낸 전체 프롬프트를 채팅창에 그대로 표시
   - 사용자가 어떤 요청을 Codex에 보냈는지 확인 가능
   - 프롬프트 구조 ([GOAL], [CONSTRAINTS] 등) 전체 표시

2. **응답 원본 표시**: Codex의 응답을 요약하지 말고 **원본 응답 전체를 그대로 채팅창에 표시**
   - Unified diff 패치 전체 표시
   - 에러 메시지가 있으면 전체 표시
   - 출력된 모든 텍스트 보존

3. **요청-응답 쌍 표시**: 요청과 응답을 명확히 구분하여 표시
   ```
   [Codex Request]
   <전체 프롬프트>
   
   [Codex Response]
   <전체 응답>
   ```

4. **추가 분석은 별도 제공**: Codex 응답을 기반으로 한 분석이나 요약은 원본 표시 후 별도로 제공

예시:
- ❌ 잘못된 방식: "Codex로 EventBus 클래스를 생성했습니다. diff 패치를 적용했습니다."
- ✅ 올바른 방식:
  ```
  [Codex Request]
  [GOAL]
  Create EventBus class...
  [전체 프롬프트]
  
  [Codex Response]
  --- /dev/null
  +++ b/src/utils/event_bus.py
  [전체 diff 패치]
  
  [Cursor 분석]
  Codex가 생성한 패치를 검토한 결과...
  ```

### 2.5 Codex 호출 로깅
Codex CLI 호출 시 다음 정보를 채팅창에 표시:
- 호출 시각
- 프롬프트 길이/구조
- 응답 상태 (성공/실패)
- 응답 길이
- 실행 시간 (가능한 경우)
# Tool Auto-Trigger Gates (Codex CLI / Perplexity MCP)

Always respond in Korean

## 1) Codex CLI 자동 트리거 조건 (문장 트리거 없이도 발동)
아래 중 하나라도 해당하면, 사용자가 명시하지 않아도 Codex CLI 협업을 사용한다.

### Codex Gate A: Code-change required
- 사용자의 요청이 "코드 변경"을 요구하거나 암시하면 Codex를 호출한다.
  - 예: bug fix, refactor, add feature, optimize, write script, implement module
  - 예: "에러 해결", "이거 고쳐", "리팩터링", "속도 개선", "모듈 추가"

### Codex Gate B: Patch/diff is the best output
- 최종 산출물이 코드/패치/설정 변경일 때는 Codex를 사용한다.

### Codex Gate C: Non-trivial code reasoning
- 로직이 복잡하거나(멀티프로세스/분산/비동기/성능), 수정 범위가 넓을 가능성이 있으면 Codex를 사용한다.

#### Codex 호출 원칙(고정)
- diff-only (unified diff)
- reproduce + verify commands 의무
- conda env 정보 포함

---

## 2) Perplexity MCP 자동 트리거 조건 (문장 트리거 없이도 발동)
아래 중 하나라도 해당하면, 사용자가 명시하지 않아도 Perplexity로 검증한다.

### Perplexity Gate A: Time-sensitive / latest
- "최신", "현재", "요즘", "업데이트", "정책", "가격", "지원 여부", "버전" 등의 시점 민감 정보가 포함되면 Perplexity를 사용한다.

### Perplexity Gate B: Fact-check / evidence needed
- 사용자가 근거/출처/레퍼런스를 요구하거나, 내가 불확실한 사실이 있으면 Perplexity를 사용한다.

### Perplexity Gate C: Unknown / ambiguous term
- 용어가 애매하거나(혹은 신조어/제품명/프로젝트명), 내가 확신할 수 없으면 Perplexity로 확인한다.

### Perplexity Gate D: Spec/compatibility questions
- "이거 되냐", "지원하냐", "호환되냐", "CLI 있냐" 같은 호환/지원 여부 질문은 Perplexity를 기본으로 사용한다.

---

## 3) 복합 요청 처리 규칙
- "개발 + 스펙 확인"이 섞인 경우:
  1) Perplexity로 사실/스펙을 먼저 확정
  2) 확정된 스펙을 Codex 입력으로 주입
  3) Codex로 patch 생성
  4) Cursor가 통합/검증

---

## 4) 사용자 문장 트리거는 보조로 유지
- 사용자가 명시하면(“퍼플렉시티로”, “Codex로”) 무조건 해당 툴 우선
- 명시가 없으면 위 Gate 규칙으로 자동 판단


